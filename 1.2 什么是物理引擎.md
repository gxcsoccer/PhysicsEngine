虽然物理学运用在游戏里已经超过三十年的时间了，但是在最近几年里它的实现发生了显著的变化。原来所有的效果都是独立编程完成的，当游戏需要的时候就现编一个。如果一个游戏需要画出延某一轨迹的弓箭，那么该轨迹的公式便会硬编码到游戏里面。这对模拟这种弓箭是完美的，除此之外别无它用。

这对于那些代码量不大并且物理效果有限的模拟已经足够了。正如我们所知，一个基本的粒子系统大概一百行左右代码就可以实现。当难度增加，它很难直接产出合格的物理效果。例如，你用不正确的代码实现推箱子，那么箱子移动就会看起来很奇怪。将各种游戏中类似的效果合并起来是有难度的，这也激励着程序员们去寻找那些通用的，可复用的解决方案。

可复用的技术需要是非常通用的：一个弹道模拟器如果只模拟弓箭，那么可以将弓箭的行为硬编码进去。如果同一份代码需要模拟子弹，那么需要从指定的抛射物中抽象出来，模拟他们共有的物理运动。这就是我们所说的物理引擎：一份通用的代码能够应对普通的物理运动，而不必为各种场景单独实现一份。

这里有一个明显的坑，如果我们有一段定制的模拟弓箭的代码，那我们不需要其他代码便能模拟弓箭。如果我们有一个通用的物理引擎，可以模拟任何抛射物，这时如果我们想模拟一个弓箭，我们还需要告诉引擎我们模拟物体的特征。我们需要弓箭，子弹或者箱子等的物理属性。

这是一个重要的区别。物理引擎基本上可以认为是一个计算器，他可以完成模拟物理运动所需的数学计算。但是它自己并不知道要模拟些什么。在拥有物理引擎的同时，我们需要游戏数据来描述游戏关卡。

虽然我们在本书中到处看到此类游戏数据，但是我不会关注该如何设置它们。在商业的游戏中，会有专门的关卡编辑器让关卡设计者去放置箱子，旗子，人偶，或者飞机；去设置它们的重量，它们移动的轨迹，它们的浮力等等。

在本书中我们要开发的物理引擎，需要用数据逐渐地驱动它。我会深入讲解这些是什么数据，它们的合理取值有那些，但是我们假设这些数据都会提供给引擎。

###物理引擎的优势
在你的游戏中使用物理引擎有两个显著的优势。第一个是节省时间。如果你希望在不只一个游戏里使用一个物理效果，那么花点时间创建一个物理引擎是值得的，你可以直接引用它到你的新项目中。一个轻量级的通用物理引擎，正如我们在本书中开发的，并不一定非常难实现。一两千行代码就可以实现绝大多数你所需要的游戏效果。

第二个原因是代码质量。随着时间推移，你很可能会加入越来越多的物理效果到你的游戏中。你可以按照你的需求实现它们。为披肩和旗子创建一个衣服模拟器，为浮起的盒子实现水模拟器，和一个单独的粒子引擎。每个工作的都很好，但是你很难合并这些效果。当一个玩家穿着飘动的披肩，站在水中。那么他的衣服如何表现？如果即使在水中，披肩也一直随风吹起，那么幻想便被识破了。

物理引擎提供使各种效果以可靠的方式交互。创建一个水，风和衣服配合的物理引擎并不容易，但是它比分别实现它们三要容易的多，并且保证它们在任何情况下看起来都是正常的。

###物理引擎的劣势
物理引擎并不是总是灵丹妙药。有些时候你并一定希望在你的游戏里面使用一个完整的物理引擎。

最常见的原因是运行速度。一个通用的物理引擎是CPU密集操作的。因为它必须是通用的，它不能为它模拟的物体做任何假设。当你的游戏非常的简单呐，那么这意味着处理能力的浪费。也许在现代的PC上这并不是什么问题，但是在手持设备，例如手机和PDA上，这个影响是显著的。在PC上你可以使用完整的物理引擎，但是要在手机上顺畅的跑同样的游戏，你需要使用一些简单的物理效果。

需要提供数据给引擎有些时候也是个问题。我最近开发的一款游戏里面只用到了旗帜在风中舞动这个物理效果，我们准备使用一个商用的物理引擎，但是开发者需要计算旗帜的所有参数，包括质量，弹性等等，这些都需要提供给物理引擎用于模拟旗帜的运动。

我们并没有合适的工具可以很容易的产出这些数据，所以我们自己开发了一小段代码专门用于旗帜的模拟，旗帜的特性都是硬编码在软件中的，游戏设计者不需要其他的工具支持便可使用。我们不选用引擎是因为定制的代码使用起来更方便。

最后一个不用引擎的理由就是项目的范围。如果你只是一天晚上心血来潮开发一款游戏，那么实现一整套物理引擎可能让你没有时间去完善你游戏的其他部分，如游戏画面和游戏逻辑。另外一方面，即使业余的游戏要和商业游戏竞争，也要注意顶级的物理效果和顶级的品牌是相称的。

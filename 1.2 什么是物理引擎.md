虽然物理学运用在游戏里已经超过三十年的时间了，但是在最近几年里它的实现发生了显著的变化。原来所有的效果都是独立编程完成的，当游戏需要的时候就现编一个。如果一个游戏需要画出延某一轨迹的弓箭，那么该轨迹的公式便会硬编码到游戏里面。这对模拟这种弓箭是完美的，除此之外别无它用。

这对于那些代码量不大并且物理效果有限的模拟已经足够了。正如我们所知，一个基本的粒子系统大概一百行左右代码就可以实现。当难度增加，它很难直接产出合格的物理效果。例如，你用不正确的代码实现推箱子，那么箱子移动就会看起来很奇怪。将各种游戏中类似的效果合并起来是有难度的，这也激励着程序员们去寻找那些通用的，可复用的解决方案。

可复用的技术需要是非常通用的：一个弹道模拟器如果只模拟弓箭，那么可以将弓箭的行为硬编码进去。如果同一份代码需要模拟子弹，那么需要从指定的抛射物中抽象出来，模拟他们共有的物理运动。这就是我们所说的物理引擎：一份通用的代码能够应对普通的物理运动，而不必为各种场景单独实现一份。

这里有一个明显的坑，如果我们有一段定制的模拟弓箭的代码，那我们不需要其他代码便能模拟弓箭。如果我们有一个通用的物理引擎，可以模拟任何抛射物，这时如果我们想模拟一个弓箭，我们还需要告诉引擎我们模拟物体的特征。我们需要弓箭，子弹或者箱子等的物理属性。

这是一个重要的区别。物理引擎基本上可以认为是一个计算器，他可以完成模拟物理运动所需的数学计算。但是它自己并不知道要模拟些什么。在拥有物理引擎的同时，我们需要游戏数据来描述游戏关卡。

虽然我们在本书中到处看到此类游戏数据，但是我不会关注该如何设置它们。在商业的游戏中，会有专门的关卡编辑器让关卡设计者去放置箱子，旗子，人偶，或者飞机；去设置它们的重量，它们移动的轨迹，它们的浮力等等。

在本书中我们要开发的物理引擎，需要用数据逐渐地驱动它。我会深入讲解这些是什么数据，它们的合理取值有那些，但是我们假设这些数据都会提供给引擎。


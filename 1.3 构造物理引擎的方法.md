创建物理引擎的方法有很多，从最简单的物理引擎到顶尖的中间件公司的产品。创建一个合格的物理引擎在于平衡开发复杂度和最终模拟的效果。

下面几节，我们将按照区别将这些方法分类。

###物体的种类
第一种是那些模拟完整的刚体的引擎和所谓的块聚合引擎（mass-aggregate engines）之间的不同。刚体引擎将物体看成一个整体，然后统一处理它们的移动和旋转。一个箱子是一个单独的物体，可以看错一个整体来模拟。块聚合引擎将物体看作由许多小块组成，一个盒子可以被模拟成由8个顶点和一些连接的棍子组成的。

块聚合引擎非常容易实现，因为它们并不需要理解旋转。每个块分别位于一个点，运动的方程可以用线性运动表示。整个物体的旋转可以自然的看作是其每个块线性运动的牵引力所导致的。

因为在物理引擎里创造真正的刚体是非常困难的，所以在块聚合引擎里面模拟坚固的物体也是很困难的。我们提到的8个顶点的箱子是具备一定的柔性的。为了不让玩家发现，我们需要用额外的代码将略有弹性的块重构为坚固的盒子。基本的块聚合系统是非常容易实现的，这些额外的检查和修正更多时候也是碰运气，我不认为值得去做的。

其他引擎使用冲力处理所有问题：放在桌子上的书是通过无数的微型的碰撞而不是一股不变的力保持在哪儿。毫无疑问，它们被称之为
幸运的是我们可以通过简单的增加旋转将块聚合引擎扩展到一个完全的刚体系统中去。这本书中我们将一个块聚合引擎逐渐演变为一个全刚体物理引擎。因为我们的目标是一个更加健壮的引擎，所以我不准备花时间去构建弹性聚合矫正代码。

###接触处理
第二个不同在于物体接触以后的处理方式。正如我们在这本书中将看到的，写一个刚体物理引擎的难点很大程度上是模拟接触，他们接触或者连接的位置。包括躺在地上的物体，连接在一块的物体，和碰撞。

一种处理方法是一个接一个的处理这些接触，并保证他们各自工作正确。这种方法叫“迭代方法”，它的优势在于速度。每个接触都很快被处理，如果只有几十个接触需要处理，那么整个处理速度也将很快。但它的弊端在于，接触可能会互相影响，有时候这种影响可能是显著的。但这是最简单的处理方法，并且也是其他复杂方法的基础。这也是我们在这本书中将使用的技术。

一个更加物理上真实的方法就是计算每个接触之间的具体影响，并且汇总成集合同时应用在所有物体上。这被称之为“雅可比矩阵法”，但是它是非常耗时的，其中设计的数学计算非常复杂，求解方程需要引入大量的计算。更糟的是，有些情况下，其实没有合理的结果，程序员需要添加特殊代码来处理当方程无法求解时。有不少中间件包使用了这种方式，它们各自有技术去求解方程以及处理不一致。

第三个方案是根据接触和对象间的牵引力计算出一个方程集。除了运用牛顿力学，我们可以根据处理的物体创建我们自己的定律。这些方程在每一帧都不同，物理引擎的主要工作就是构造这个方程集（即使求解这些方程集叶不是容易的事情）。这种方法被称之为“约化坐标法”。某些物理系统使用该方法构建，这也是目前工程软件里面最常用的精确模拟方法。不幸的是，它非常的慢，不是很适合游戏程序，因为它对速度的要求超过精确度。

在我们了解第一种方法后，我们会在18章回来讨论其他方法。

###冲力和力
第三点不同在于引擎如何处理接触，这请容许我解释一下。

一本书放在桌子上，桌子对书有一股等于重力的朝上的力。如果桌子对书没有作用力，那么书会陷入到桌子里。这股力会一直作用于书，只要它还放在哪儿。书的速度没有变化。

对比地上反弹的球。球碰撞地面，地面反向推动球加速向上直到球以一个向上的速度离开桌面。速度的变化是由一股力造成的。这被称之为“冲力”

一些物理引擎用冲力描述碰撞，用力来描述其他类型的接触。当然这是不多见的，因为需要区别处理力和冲力。更常见的做法是物理引擎将它们都当作力，冲力是一种非常短时间内生效的力。这是以力为基础的引擎，它以现实世界的方式工作。不幸的是力的数学比冲力的数学要难。那些以力为基础的引擎往往是使用“雅可比矩阵法”或“约化坐标法”的。少有几个顶尖中间件是基于力的。

其他引擎使用冲力处理所有问题：放在桌子上的书，是因为无数微小的碰撞保持在哪儿，而不是因为一股不变的力。毫无疑问，这种引擎被称之为“以冲力为基础”的引擎。在游戏的每一帧这本书将受到一股小碰撞让其保持在桌面上直到下一帧，如果帧率显著下降，放在平面上的物体会发生为振动。然而在绝大多数情况下，它和以力为基础的方法没什么不同。这将是我们在本书中使用的方法，它很容易实现，并且有较好的灵活性和适应性。它已经被很多中间件包所使用，同时也被很多商业的应用所证明。
